import { Router } from 'express';
import { z } from 'zod';
import { prisma } from '../lib/prisma';
import { hasPermission } from '../lib/permissions';
import { authenticate, requireRole } from '../middleware/auth';

export const router = Router();

const createSchema = z.object({
  type: z.enum(['INDIVIDUAL', 'BUSINESS']),
  firstName: z.string().optional(),
  lastName: z.string().optional(),
  companyName: z.string().optional(),
  email: z.string().email(),
  phone: z.string().optional(),
  preferredCurrency: z.string().default('TZS'),
  street: z.string().optional(),
  city: z.string().optional(),
  state: z.string().optional(),
  zipCode: z.string().optional(),
  country: z.string().optional(),
});

// Customer number is now auto-generated by the database
// Frontend will format it as CUST000001, CUST000002, etc.

router.use(authenticate);




// Get customer's own profile (for customer users)
router.get('/me', async (req, res) => {
  try {
    const jwtUser = (req as any).user;

    // Only allow customer users to access this endpoint
    if (jwtUser.role !== 'CUSTOMER') {
      return res.status(403).json({ error: 'This endpoint is only for customer users' });
    }

    // Find customer by ownerId (stable link to the authenticated user)
    const customer = await prisma.customer.findFirst({
      where: { ownerId: jwtUser.sub },
      include: {
        _count: {
          select: {
            shipments: true
          }
        }
      }
    });

    if (!customer) {
      return res.status(404).json({ error: 'Customer profile not found' });
    }

    // Transform the response to include shipmentCount at the top level
    const customerWithCount = {
      ...customer,
      shipmentCount: customer._count?.shipments || 0,
      _count: undefined // Remove the nested _count object
    };

    res.json(customerWithCount);
  } catch (error) {
    console.error('Error fetching customer profile:', error);
    res.status(500).json({ error: 'Failed to fetch customer profile' });
  }
});

router.get('/', async (req, res) => {
  try {
    const user = (req as any).user;
    if (user.role === 'CUSTOMER') {
      return res.status(403).json({ error: 'Forbidden' });
    }
    {
      const ok = await hasPermission(user.sub, 'customers:read');
      if (!ok) return res.status(403).json({ error: 'Forbidden' });
    }


    const customers = await prisma.customer.findMany({
      include: {
        _count: { select: { shipments: true } }
      }
    });

    // Transform the response to include shipmentCount at the top level
    const customersWithCount = customers.map(customer => ({
      ...customer,
      shipmentCount: customer._count?.shipments || 0,
      _count: undefined // Remove the nested _count object
    }));

    res.json(customersWithCount);
  } catch (error) {
    console.error('Error fetching customers:', error);
    res.status(500).json({ error: 'Failed to fetch customers' });
  }
});

router.get('/:id', async (req, res) => {
  try {
    const id = req.params.id;
    const user = (req as any).user;
    if (user.role !== 'CUSTOMER') {
      const ok = await hasPermission(user.sub, 'customers:read');
      if (!ok) return res.status(403).json({ error: 'Forbidden' });
    }

    const customer = await prisma.customer.findUnique({
      where: { id },
      include: {
        _count: {
          select: {
            shipments: true
          }
        }
      }
    });
    if (!customer) return res.status(404).json({ error: 'Customer not found' });
    if (user.role === 'CUSTOMER' && customer.ownerId !== user.sub) {
      return res.status(403).json({ error: 'Forbidden', message: 'Access denied to this customer record' });
    }

    // Transform the response to include shipmentCount at the top level
    const customerWithCount = {
      ...customer,
      shipmentCount: customer._count?.shipments || 0,
      _count: undefined // Remove the nested _count object
    };

    res.json(customerWithCount);
  } catch (error) {
    console.error('Error fetching customer:', error);
    res.status(500).json({ error: 'Failed to fetch customer' });
  }
});

router.post('/', async (req, res) => {
  try {
    const user = (req as any).user;
    if (user.role === 'CUSTOMER') return res.status(403).json({ error: 'Forbidden' });
    {
      const ok = await hasPermission(user.sub, 'customers:create');
      if (!ok) return res.status(403).json({ error: 'Forbidden' });
    }

    const parsed = createSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: 'Invalid data', details: parsed.error.issues });
    }

    const customer = await prisma.customer.create({
      data: parsed.data
      // customerNumber will be auto-generated by database
    });

    res.status(201).json(customer);
  } catch (error: any) {
    console.error('Error creating customer:', error);
    if (error.code === 'P2002') {
      if (error.meta?.target?.includes('email')) {
        return res.status(409).json({
          error: 'Email already exists',
          message: 'A customer with this email address already exists.'
        });
      }
      return res.status(409).json({
        error: 'Duplicate data',
        message: 'Customer with this information already exists.'
      });
    }
    res.status(500).json({ error: 'Internal server error', message: 'Failed to create customer' });
  }
});

router.patch('/:id', async (req, res) => {
  try {
    const user = (req as any).user;
    if (user.role === 'CUSTOMER') return res.status(403).json({ error: 'Forbidden' });
    {
      const ok = await hasPermission(user.sub, 'customers:update');
      if (!ok) return res.status(403).json({ error: 'Forbidden' });
    }

    const id = req.params.id;
    const data = req.body as any;
    const updated = await prisma.customer.update({ where: { id }, data });
    res.json(updated);
  } catch (error: any) {
    console.error('Error updating customer:', error);
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Customer not found' });
    }
    if (error.code === 'P2002') {
      return res.status(409).json({ error: 'Duplicate data', message: 'Customer with this information already exists' });
    }
    res.status(500).json({ error: 'Failed to update customer' });
  }
});

router.delete('/:id', async (req, res) => {
  try {
    const user = (req as any).user;
    if (user.role === 'CUSTOMER') return res.status(403).json({ error: 'Forbidden' });
    {
      const ok = await hasPermission(user.sub, 'customers:delete');
      if (!ok) return res.status(403).json({ error: 'Forbidden' });
    }

    const id = req.params.id;
    await prisma.customer.delete({ where: { id } });
    res.status(204).send();
  } catch (error: any) {
    console.error('Error deleting customer:', error);
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Customer not found' });
    }
    if (error.code === 'P2003') {
      return res.status(409).json({
        error: 'Cannot delete customer',
        message: 'Customer has associated records (shipments, invoices, etc.)'
      });
    }
    res.status(500).json({ error: 'Failed to delete customer' });
  }
});

// Admin: Link a portal User to a Customer (sets ownerId)
const linkSchema = z.object({
  userId: z.string().optional(),
  email: z.string().email().optional(),
  force: z.boolean().optional()
}).refine((v) => !!v.userId || !!v.email, { message: 'userId or email is required' });

router.post('/:id/link-user', async (req, res) => {
  try {
    const actor = (req as any).user;
    if (actor.role === 'CUSTOMER') return res.status(403).json({ error: 'Forbidden' });
    {
      const ok = await hasPermission(actor.sub, 'customers:update');
      if (!ok) return res.status(403).json({ error: 'Forbidden' });
    }

    const { id } = req.params;
    const parsed = linkSchema.safeParse(req.body);
    if (!parsed.success) return res.status(400).json({ error: 'Invalid data', details: parsed.error.issues });

    const customer = await prisma.customer.findUnique({ where: { id } });
    if (!customer) return res.status(404).json({ error: 'Customer not found' });

    const whereUser: any = parsed.data.userId ? { id: parsed.data.userId } : { email: parsed.data.email };
    const user = await prisma.user.findUnique({ where: whereUser });
    if (!user) return res.status(404).json({ error: 'User not found' });

    // If already linked and not forcing, block
    if (customer.ownerId && customer.ownerId !== user.id && !parsed.data.force) {
      return res.status(409).json({ error: 'Customer already linked', message: 'Unlink first or set force=true' });
    }

    // Prevent linking a user who is already linked to another customer
    const other = await prisma.customer.findFirst({ where: { ownerId: user.id, NOT: { id } } });
    if (other) {
      return res.status(409).json({ error: 'User already linked', message: 'This user is already linked to another customer' });
    }

    const updated = await prisma.customer.update({ where: { id }, data: { ownerId: user.id } });

    // Audit log
    try {
      await prisma.auditLog.create({ data: { actorId: actor.sub, action: 'customer.link_user', entityType: 'Customer', entityId: id, details: { toUserId: user.id } as any } });
    } catch {}

    res.json(updated);
  } catch (error: any) {
    console.error('Error linking user to customer:', error);
    if (error.code === 'P2002') {
      return res.status(409).json({ error: 'Conflict', message: 'User already linked to a customer' });
    }
    res.status(500).json({ error: 'Failed to link user to customer' });
  }
});

// Admin: Unlink a portal User from a Customer (clears ownerId)
router.post('/:id/unlink-user', async (req, res) => {
  try {
    const actor = (req as any).user;
    if (actor.role === 'CUSTOMER') return res.status(403).json({ error: 'Forbidden' });
    {
      const ok = await hasPermission(actor.sub, 'customers:update');
      if (!ok) return res.status(403).json({ error: 'Forbidden' });
    }

    const { id } = req.params;
    const customer = await prisma.customer.findUnique({ where: { id } });
    if (!customer) return res.status(404).json({ error: 'Customer not found' });

    if (!customer.ownerId) return res.status(200).json(customer); // already unlinked

    const updated = await prisma.customer.update({ where: { id }, data: { ownerId: null } });

    try {
      await prisma.auditLog.create({ data: { actorId: actor.sub, action: 'customer.unlink_user', entityType: 'Customer', entityId: id, details: {} as any } });
    } catch {}

    res.json(updated);
  } catch (error) {
    console.error('Error unlinking user from customer:', error);
    res.status(500).json({ error: 'Failed to unlink user from customer' });
  }
});


